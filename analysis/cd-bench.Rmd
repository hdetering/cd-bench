---
title: "Clonal Deconvolution Benchmarking Study"
author: "Harald Detering"
date: "October 12, 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(tidyverse)
library(ggforce) # geom_sina
library(rstatix) # wilcox_test
library(ggpubr) # stat_pvalue_manual
library(scales) # trans_breaks
library(lemon) # reposition_legend
library(ggh4x) # facet_nested_wrap

# define significance levels for p-values
psig_cut = c(0, 0.001, 0.01, 0.05, 1)
psig_sym = c("***", "**", "*", "")

# color blind-friendly palette
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

data_dir <- 'data'
# df_rep <- list.files( pattern = 'df_rep.csv', recursive = TRUE ) %>%
#   map_df( ~ { read_csv(., skip = 1,
#                        col_names = c('id_rep', 'n_clones', 'n_samples', 'purity', 'depth', 'n_muts', 'cnv_rate', 'n_snvs'),
#                        col_types = 'ciidiidi') } )
df_rep <- read_csv( file.path(data_dir, 'df_rep.csv'), skip = 1,
                    col_names = c('id_rep', 'n_clones', 'n_samples', 'purity', 'depth', 'n_muts', 'cnv_rate', 'n_snvs'),
                    col_types = 'ciidiidi' ) %>% 
  extract( id_rep, c('id_rep_short'), '(\\w+)[-0-9a-f]', remove = FALSE )
df_cn <- read_delim( 'reps_clones_cn.tsv', delim = '\t', 
                   col_names = c('id_rep', 'id_clone', 'chrom', 'start', 'end', 'cn_A', 'cn_B'),
                   col_types = 'fcciidd')
# calculate CNV mutation burden per replicate
df_cn_dipl <- df_cn %>% 
  dplyr::filter( cn_A == 1, cn_B == 1 ) %>% 
  group_by( id_rep )  %>% 
  summarise( cn2_len = sum(end-start) ) %>% 
  inner_join( df_rep ) %>% 
  mutate( cnv_burden = 1-(cn2_len/(n_clones*1e+7)) )
# add CNV mut burden to df_rep
df_rep <- df_rep %>% 
  left_join( df_cn_dipl %>% dplyr::select(id_rep, cnv_burden), by = 'id_rep' )

df_seqz_purity <- read_delim( file.path(data_dir, 'sequenza_purity.tsv'), delim = '\t',
                              col_types = 'fcddd' )
df_seqz_cn2_rep <- read_csv( file.path(data_dir, 'df_seqz_cn2_mse_rep.csv') ) %>% 
  dplyr::select( -n_vars ) %>% # n_vars is non-unique count!
  rename( seqz_mse = mse )
# add Sequenza MSE scores to df_rep
df_rep <- df_rep %>% 
  left_join( df_seqz_cn2_rep, by = c('id_rep_short' = 'id_rep') )

# load clustering scores
fn_clust <- file.path( data_dir, 'metrics_clustering.csv' )
df_clust <- read_csv( fn_clust, col_types = 'ccdddddddd' ) %>%
  #replace_na( list(n_clust_inf = 0) ) %>% 
  separate( tool, c('cd_tool', 'cn_filter', 'cn_tool'), sep = '_', remove = FALSE, fill = 'right' ) %>% 
  replace_na( list(cn_tool = 'seqz') )
df_clust_cn2_seqz <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F )

# load prevalence scores
fn_metr_prev <- file.path( data_dir, 'metrics_prevalence.csv' )
df_metr_prev <- read_csv( fn_metr_prev ) %>% 
  separate( tool, c('cd_tool', 'cn_filter', 'cn_tool'), sep = '_', remove = FALSE, fill = 'right' ) %>% 
  replace_na( list(cn_tool = 'seqz') )
df_prev_cn2_seqz <- df_metr_prev %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F )

# load clone tree scores
fn_phylo <- file.path( data_dir, 'metrics_phylogeny.csv' )
df_phylo <- read_csv( fn_phylo ) %>% 
  separate( tool, c('cd_tool', 'cn_filter', 'cn_tool'), sep = '_', remove = FALSE, fill = 'right' ) %>% 
  replace_na( list(cn_tool = 'seqz') )
df_phylo_cn2_seqz <- df_phylo %>% 
  dplyr::filter( cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F )
```

```{r util}
## utility functions

# place legend in empty facets
shift_legend <- function(p) {
    pnls <- cowplot::plot_to_gtable(p) %>% gtable::gtable_filter("panel") %>%
      with(setNames(grobs, layout$name)) %>% purrr::keep(~identical(.x,zeroGrob()))

    if( length(pnls) == 0 ) stop( "No empty facets in the plot" )

    lemon::reposition_legend( p, "center", panel=names(pnls) )
}
```


Let's try some regression models on relating the performance scores to influence variables

```{r regression}
library(arm)
library(parameters)
models <- df_clust_cn2_seqz %>% 
  mutate( n_clone_err = abs(n_clust_inf - n_clust_true) ) %>% 
  inner_join( df_rep, by = 'id_rep' ) %>% 
  group_by( cd_tool ) %>% nest() %>%
  mutate( model = map(data, ~lm(n_clone_err ~ n_clones + n_samples + purity + depth + n_snvs + cnv_rate + seqz_mse, data = .)),
          results = map(model, augment) ) %>% 
  unnest( results )
models

models <- df_clust_cn2_seqz %>% 
  mutate( n_clone_err = abs(n_clust_inf - n_clust_true) ) %>% 
  inner_join( df_rep, by = 'id_rep' ) %>% 
  group_by( cd_tool ) %>% nest() %>%
  mutate( model = map(data, ~lm(n_clone_err ~ n_clones + n_samples + purity + depth + n_snvs + cnv_rate + seqz_mse, data = .)),
          #model_std = map(model, arm::standardize(.)),
          model_beta = map(model, ~lm.beta),
          results = map(model, tidy) ) %>% 
          #results = map(model_beta, ~model_parameters(.)) ) %>% 
  unnest( results )
models

models %>% 
  ggplot(aes(x = n_clones, y = .fitted)) +
  geom_abline(intercept = 0, slope = 1, alpha = .2) +
  geom_point() +
  facet_wrap( ~cd_tool, scales = 'free' )

```


## Dataset

This simulation study contains 100 replicates with the following properties:
(Expected distributions indicated by dashed red lines.)

### Number of clones

```{r meta_reps_clones}
ggplot( df_rep ) + geom_bar( aes(x = n_clones) ) +
  geom_hline( yintercept = 500/(10-2+1), linetype = 'dashed', color = 'red' ) +
  #ggtitle( 'Number of clones' ) +
  scale_x_continuous( breaks = 2:10 ) +
  labs( x = 'number of clones' ) +
  theme_minimal()
ggsave( filename = 'plot/reps_nclones.pdf', device = 'pdf', width = 6, height = 3 )
ggsave( filename = 'plot/reps_nclones.png', device = 'png', width = 6, height = 3 )
```

### Number of samples

```{r meta_reps_samples}
ggplot( df_rep ) + geom_bar( aes(x = n_samples) ) +
  geom_hline( yintercept = 500/(10-3+1), linetype = 'dashed', color = 'red' ) +
  scale_x_continuous( breaks = 3:10 ) +
  labs( x = 'number of samples' ) +
  theme_minimal()
ggsave( filename = 'plot/reps_nsamples.pdf', device = 'pdf', width = 6, height = 3 )
ggsave( filename = 'plot/reps_nsamples.png', device = 'png', width = 6, height = 3 )
```

### Number of clones and samples

```{r meta_reps_clones_samples}
df_rep %>% dplyr::group_by( n_samples, n_clones) %>% tally() %>%
  ggplot() + geom_point( aes(x = n_samples, y = n_clones, size = n, fill = n), shape = 21 ) +
  scale_fill_continuous(type = "viridis") +
  scale_x_continuous( breaks = 3:10, minor_breaks = NULL ) +
  scale_y_continuous( breaks = 2:10, minor_breaks = NULL ) +
  labs( x = 'number of samples', y = 'number of clones' ) +
  theme_minimal()
ggsave( filename = 'plot/reps_nsamples_nclones.pdf', device = 'pdf', width = 6, height = 3 )
ggsave( filename = 'plot/reps_nsamples_nclones.png', device = 'png', width = 6, height = 3 )
```


### Sequencing depth

```{r meta_reps_depth}
ggplot( df_rep ) + geom_bar( aes(x = as.factor(depth)) ) +
  labs( x = 'depth' ) +
  ggtitle( 'Sequencing depth' )
```

### Purity

```{r meta_reps_purity}
df_rep %>%
  ggplot( aes(x = 1-purity) ) + 
  geom_histogram( aes(y = ..density..), bins = 20, fill = 'grey42' ) +
  stat_function( fun = dbeta, args = list(shape1 = 1.65, shape2 = 5.45 ), color = 'red', lty = 2 ) +
  theme_minimal()
  #ggtitle( 'Normal cell contamination' )
ggsave( filename = 'plot/reps_purity.pdf', device = 'pdf', width = 6, height = 3 )
ggsave( filename = 'plot/reps_purity.png', device = 'png', width = 6, height = 3 )
```

```{r meta_reps_purity_depth}
df_rep %>%
  ggplot( aes(x = as.factor(depth), y = 1-purity) ) + 
  geom_violin() +
  geom_sina() +
  labs( x = 'depth' ) +
  ggtitle( 'Normal cell contamination by sequencing depth' ) +
  theme_minimal()
```

### Number of SNVs

```{r meta_reps_snv}
p_reps_nsnvs <- df_rep %>%
  ggplot( aes(x = n_snvs) ) + 
  geom_histogram( bins = 50, fill = 'grey42' ) +
  labs( x = 'number of SNVs' ) +
  #stat_function( fun = dbeta, args = list(shape1 = 1.65, shape2 = 5.45 ), color = 'red', lty = 2 ) +
  theme_minimal()
  #ggtitle( 'Normal cell contamination' )
ggsave( filename = 'plot/reps_nsnvs.pdf', plot = p_reps_nsnvs, device = 'pdf', width = 6, height = 3 )
ggsave( filename = 'plot/reps_nsnvs.png', plot = p_reps_nsnvs, device = 'png', width = 6, height = 3 )
p_reps_nsnvs
```


### Copy number-aberrant regions

```{r meta_reps_cn}
# calculate the total length of diploid regions per replicate
df_cn_dipl <- df_cn %>% 
  dplyr::filter( cn_A == 1, cn_B == 1 ) %>% 
  group_by( id_rep )  %>% 
  summarise( cn2_len = sum(end-start) ) %>% 
  inner_join( df_rep ) %>% 
  mutate( cn2_ratio = cn2_len/(n_clones*1e+7) )

p_cn_burden <- df_cn_dipl %>% 
  ggplot( aes(x = n_snvs, y  = 1-cn2_ratio) ) +
  geom_point() +
  labs( x = 'number of SNVs', y = 'CNV-affected fraction of genome' ) +
  theme_minimal()
ggsave( filename = 'plot/reps_snvs_cnvs.pdf', plot = p_cn_burden, device = 'pdf', width = 6, height = 3 )
ggsave( filename = 'plot/reps_snvs_cnvs.png', plot = p_cn_burden, device = 'png', width = 6, height = 3 )
p_cn_burden
```



## Results

### Purity inference (Sequenza)

Compare difference between median inferred purity vs. true.

```{r seqz_purity}
# calculate median purity value per tumor
p_seqz_purity <- df_seqz_purity %>% #group_by( id_rep ) %>% 
  rename( inf_purity = purity ) %>% 
  #summarise( inf_purity = median(purity) ) %>% 
  inner_join( df_rep, by = 'id_rep' ) %>% 
  rename( true_purity = purity ) %>% 
  ggplot( aes(x = as.factor(depth), y = inf_purity-true_purity) ) +
  geom_violin() + geom_boxplot( width = .1 ) +
  geom_hline( yintercept = 0, color = 'blue' ) +
  labs( x = 'depth' ) +
  theme_minimal()
ggsave( filename = 'plot/sequenza_purity.pdf', plot = p_seqz_purity, device = 'pdf', width = 6, height = 3 )
ggsave( filename = 'plot/sequenza_purity.png', plot = p_seqz_purity, device = 'png', width = 6, height = 3 )
p_seqz_purity
```


### Clustering accuracy

```{r, clust_load_data, message=F}
fn_clust <- file.path( data_dir, 'metrics_clustering.csv' )
df_clust <- read_csv( fn_clust, col_types = 'ccdddddddd' ) %>%
  #replace_na( list(n_clust_inf = 0) ) %>% 
  separate( tool, c('cd_tool', 'cn_filter', 'cn_tool'), sep = '_', remove = FALSE, fill = 'right' ) %>% 
  replace_na( list(cn_tool = 'seqz') )
```

The first qualitative criterion of interest is deconvolution success, i.e., for how many replicates a result was produced at all.

```{r, clust_success}
# df_clust %>%
#   inner_join( df_rep, by = c('id_rep') ) %>%
#   mutate( tool = str_replace(tool, '_strict', '') ) %>%
#   complete( id_rep, tool, fill = list(n_clust_inf = 0) ) %>%
#   mutate( success = (n_clust_inf > 0) ) %>%
#   ggplot( aes(x = success) ) + geom_bar( aes(fill = success) ) +
#   scale_fill_manual( values = c('red3', 'green3') ) +
#   facet_wrap( ~ tool ) +
#   theme_minimal()

# only for cn2_seqz sets
p_success <- df_clust %>%
  inner_join( df_rep, by = c('id_rep') ) %>%
  complete( id_rep, tool, fill = list(n_clust_inf = 0) ) %>%
  mutate( success = (n_clust_inf > 0) ) %>%
  separate( tool, c('cd_tool', 'cn_filter', 'cn_tool'), sep = '_', remove = F, fill = 'right') %>%
  dplyr::filter( cn_filter == 'cn2', cn_tool == 'seqz' ) %>%
  ggplot( aes(x = success) ) + geom_bar( aes(fill = success) ) +
  scale_fill_manual( values = c('grey', 'steelblue') ) +
  facet_wrap( ~ cd_tool ) +
  theme_minimal() +
  theme( strip.text = element_text(size = 10),
         axis.text.x = element_blank(),
         axis.title.x = element_blank() )
p_success <- shift_legend(p_success)
ggsave( filename = 'plot/success.pdf', plot = p_success, device = 'pdf', width = 4, height = 3 )
ggsave( filename = 'plot/success.png', plot = p_success, device = 'png', width = 4, height = 3 )
p_success
```

#### Number of clusters

Let's compare the results when using SNVs filtered using inferred CN state by Bcftools vs. Sequenza.

```{r clust_bcf_seqz}
reps_bcftools <- df_clust %>% 
  dplyr::filter( cn_tool == 'bcftools' ) %>% 
  select( id_rep ) %>%  unique()
p_clust_bcf_seqz <- df_clust %>%
  inner_join( reps_bcftools ) %>% 
  dplyr::filter( n_clust_inf > 0, cn_filter != 'cn' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F ) %>% 
  ggplot( aes(x = lbl, y = n_clust_inf-n_clust_true) ) +
  geom_violin() + geom_boxplot( width = .1 ) +
  #ggplot( aes(x = n_clust_inf-n_clust_true) ) +
  #geom_histogram( binwidth = 1 ) +
  geom_hline(aes( yintercept = 0), color = "blue", size = 1 ) +
  facet_wrap( ~cd_tool, scales = 'free' ) +
  labs( x = '', y = 'clone number error' ) +
  #ggtitle( 'Difference inferred number of clusters to truth' ) +
  theme_minimal()
ggsave( filename = 'plot/clust_bcf_seqz.pdf', plot = p_clust_bcf_seqz, device = 'pdf', width = 8, height = 6 )
ggsave( filename = 'plot/clust_bcf_seqz.png', plot = p_clust_bcf_seqz, device = 'png', width = 8, height = 6 )
p_clust_bcf_seqz
```

Do CNV burden and inferred CN error (Sequenza) correlate?

```{r cn_burden_err}
cor.test( df_rep$cnv_burden, df_rep$seqz_mse )

df_rep %>% 
  dplyr::filter( seqz_mse > 0 ) %>% 
  ggplot( aes(x = cnv_burden, y = seqz_mse) ) +
  geom_point() +
  coord_trans( x = 'log10', y = 'log10' ) +
  theme_minimal()
```


The most basic clustering metric is the number of inferred vs. true clones.

```{r clust_num}
df_clust %>% dplyr::filter( n_clust_inf > 0 ) %>%
  #mutate( delta = ifelse(n_clust_inf-n_clust_true==0, 0, ifelse(n_clust_inf-n_clust_true>0, 1, -1))) %>%
  mutate( tool = str_replace(tool, '_strict', '') ) %>%
  ggplot( aes(x = tool, y = n_clust_inf-n_clust_true) ) +
  geom_violin() + geom_sina() +
  geom_abline(intercept = 0, slope = 0, color = 'tomato', lty = 2 ) +
  theme( axis.text.x = element_text(angle = 45, hjust=1) )

# df_clust %>% dplyr::filter( n_clust_inf > 0 ) %>%
#   pivot_wider( 
#     id_cols = c(id_rep, cd_tool, cn_filter, n_clust_true), 
#     names_from = cn_tool, 
#     values_from = n_clust_inf ) %>% 
#   unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F ) %>%
#   ggplot( aes(x = lbl, y = n_clust_inf-n_clust_true) ) +
#   geom_violin() + geom_boxplot( width = .1 ) +
#   geom_hline(aes( yintercept = 0), color = "blue", size = 1 ) +
#   facet_wrap( ~cd_tool, scales = 'free' ) +
#   labs( x = '', y = 'inferred clusters - true clusters' ) +
#   theme_minimal()


df_clust_cn2_seqz <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F )
p_nclust <- df_clust_cn2_seqz %>% 
  ggplot( aes(x = cd_tool, y = n_clust_inf-n_clust_true) ) +
  geom_violin() + geom_boxplot( width = .1 ) +
  #ggplot( aes(x = n_clust_inf-n_clust_true) ) +
  #geom_histogram( binwidth = 1 ) +
  geom_hline(aes( yintercept = 0), color = "blue", size = 1 ) +
  facet_wrap( ~cd_tool, nrow = 1, scales = 'free' ) +
  labs( x = '', y = 'clone number error' ) +
  #ggtitle( 'Difference inferred number of clusters to truth' ) +
  theme_minimal() +
  theme( axis.text.x = element_blank() )
ggsave( filename = 'plot/clust_num.pdf', plot = p_nclust, device = 'pdf', width = 8, height = 3 )
ggsave( filename = 'plot/clust_num.png', plot = p_nclust, device = 'png', width = 8, height = 3 )
p_nclust
```

Let's calulate the correlation between clone number, it's error and influence variables.

```{r clust_num_cor}
df_clust_cn2_seqz <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F )

df_clust_cor <- df_clust_cn2_seqz %>%
  mutate( clone_num_err = n_clust_inf-n_clust_true ) %>% 
  inner_join( df_rep, by = 'id_rep' ) %>%
  rename( n_clone_inf = n_clust_inf, n_clone_true = n_clust_true ) %>% 
  group_by( cd_tool ) %>% 
  cor_test( 
    vars  = c('clone_num_err', 'n_clone_inf'), 
    vars2 = c('n_clone_true', 'n_samples', 'purity', 'n_snvs', 'depth', 'cnv_burden', 'seqz_mse') ) %>% 
  adjust_pvalue() %>% 
  add_significance(p.col = 'p.adj', cutpoints = psig_cut, symbols = psig_sym ) %>% 
  mutate( cor_sig = sprintf('%.2f (%s)', cor, p.adj.signif) ) %>% 
  pivot_wider( id_cols = c(cd_tool, var1), names_from = 'var2', values_from = c('cor', 'p.adj.signif') )
  #pivot_wider( id_cols = c(cd_tool, var1), names_from = 'var2', values_from = 'cor_sig' )
df_clust_cor %>% write_csv( 'df_nclones_cor.csv' )
df_clust_cor
```

The following table shows the median of each performance metric for all tools.

```{r clust_num_tab}
df_clust_cn2_seqz %>% 
  group_by(tool) %>% 
  summarize( 
    med_clust_diff = median(n_clust_inf-n_clust_true),
    med_ari = median(ARI),
    med_v = median(V_measure),
    med_compl = median(completeness),
    med_homog = median(homogeneity))
```

The following plot shows the total number of inferred clusters for all tools.

```{r clust_num_abs}
df_clust_cn2_seqz %>% dplyr::filter( n_clust_inf > 0 ) %>%
  ggplot( aes(x = n_clust_inf) ) +
  geom_histogram( binwidth = 1 ) +
  facet_wrap( ~cd_tool, nrow = 1, scales = 'free' ) +
  #ggtitle( 'Inferred number of clusters' ) +
  theme_minimal()
```


Observation:

* although not visible in this plot, Cloe and PhyloWGS inferred a single cluster in the vast majority of replicates. (I don't no why, yet...)
* pyclone infers by far more clusters than other tools. this is in conflict with other results, e.g. in the MOBSTER paper, where PyClone **and** SciClone showed similar tendencies to over-splitting
* should this be the final result, a logarithmic y-scale would be better (e.g. log(k_fit/k_true) as in MOBSTER paper)

```{r clust_num_nclones}
df_clust_cn2_seqz <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F )
p_clust_num_nclones <- df_clust_cn2_seqz %>% 
  dplyr::filter( n_clust_inf <= 700 ) %>% 
  ggplot( aes(x = as.factor(n_clust_true), y = n_clust_inf-n_clust_true) ) +
  geom_violin() + geom_boxplot( width = .2 ) +
  #geom_label( data = df_clust_cn2_seqz %>% group_by(cd_tool) %>% summarise(r2 = cor(n_clust_true, n_clust_inf, method = "pearson"), y_max = max(n_clust_inf)), aes(x = 1, y = y_max, label = sprintf('r2 = %.2f', r2)), alpha = 0.5, hjust = 'inward', vjust = 'inward' ) +
  geom_hline(aes( yintercept = 0), color = "blue", size = 1 ) +
  facet_wrap( ~cd_tool, nrow = 4, scales = 'free' ) +
  labs( x = 'simulated no. clones', y = 'clone number error' ) +
  #ggtitle( 'Difference inferred number of clusters to truth' ) +
  theme_minimal()
#p_clust_num_nclones <- shift_legend(p_clust_num_nclones)
ggsave( filename = 'plot/clust_num_nclones.pdf', plot = p_clust_num_nclones, device = 'pdf', width = 6, height = 8 )
ggsave( filename = 'plot/clust_num_nclones.png', plot = p_clust_num_nclones, device = 'png', width = 6, height = 8 )
p_clust_num_nclones
```

```{r clust_num_nsamples}
df_clust_cn2_seqz <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F )
p_nclust <- df_clust_cn2_seqz %>% 
  dplyr::filter( n_clust_inf <= 700 ) %>% 
  inner_join( df_rep, by = 'id_rep' ) %>% 
  ggplot( aes(x = as.factor(n_samples), y = n_clust_inf - n_clust_true) ) +
  geom_violin() + geom_boxplot( width = .2 ) +
  geom_hline(aes( yintercept = 0), color = "blue", size = 1 ) +
  facet_wrap( ~cd_tool, nrow = 4, scales = 'free_y' ) +
  labs( x = 'number of samples', y = 'clone number error' ) +
  #ggtitle( 'Difference inferred number of clusters to truth' ) +
  theme_minimal()
ggsave( filename = 'plot/clust_num_nsamples.pdf', plot = p_nclust, device = 'pdf', width = 6, height = 8 )
ggsave( filename = 'plot/clust_num_nsamples.png', plot = p_nclust, device = 'png', width = 6, height = 8 )
p_nclust
```

```{r clust_num_purity}
df_clust_cn2_seqz <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' )
p_nclust_purity <- df_clust_cn2_seqz %>% 
  dplyr::filter( n_clust_inf <= 700 ) %>% 
  ggplot( aes(x = purity, y = n_clust_inf - n_clust_true) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  #scale_fill_distiller(palette= "Spectral", direction=1) +
  scale_fill_gradient( low = 'white', high = 'red' ) +
  geom_hline(aes( yintercept = 0), color = 'blue', size = .5 ) +
  geom_smooth( se = FALSE, color = 'green3', size = .5 ) +
  geom_point( size = .5 ) +
  facet_wrap( ~cd_tool, nrow = 4, scales = 'free' ) +
  labs( x = 'tumor purity', y = 'clone number error' ) +
  theme_minimal() +
  theme( axis.text = element_text(size = 8) ) +
  theme(legend.position = c(1,0),
        legend.justification = c(1, 0),
        legend.direction = 'horizontal')
p_nclust_purity <- shift_legend(p_nclust_purity)
ggsave( filename = 'plot/clust_num_purity.pdf', plot = p_nclust_purity, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_num_purity.png', plot = p_nclust_purity, device = 'png', width = 6, height = 6 )
p_nclust_purity
```

```{r clust_num_nsnvs}
df_clust_cn2_seqz <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' )
p_nclust_nsnvs <- df_clust_cn2_seqz %>% 
  dplyr::filter( n_clust_inf <= 700 ) %>% 
  ggplot( aes(x = n_snvs, y = n_clust_inf - n_clust_true) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  scale_fill_gradient( low = 'white', high = 'red' ) +
  geom_hline(aes( yintercept = 0), color = "blue" ) +
  geom_smooth( se = FALSE, color = 'green3' ) +
  geom_point( size = .5 ) +
  facet_wrap( ~cd_tool, nrow = 4, scales = 'free_y' ) +
  labs( x = 'number of SNVs', y = 'clone number error' ) +
  theme_minimal() +
  theme( axis.text = element_text(size = 8) ) +
  theme(legend.position = c(1,0),
        legend.justification = c(1, 0),
        legend.direction = 'horizontal')
p_nclust_nsnvs <- shift_legend(p_nclust_nsnvs)
ggsave( filename = 'plot/clust_num_nsnvs.pdf', plot = p_nclust_nsnvs, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_num_nsnvs.png', plot = p_nclust_nsnvs, device = 'png', width = 6, height = 6 )
p_nclust_nsnvs
```

```{r clust_num_depth}
df_clust_cn2_seqz <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' )
p_clust_num_depth <- df_clust_cn2_seqz %>% 
  dplyr::filter( n_clust_inf <= 700 ) %>% 
  ggplot( aes(x = as.factor(depth), y = n_clust_inf - n_clust_true) ) +
  geom_violin() + geom_boxplot( width = .2 ) +
  geom_hline(aes( yintercept = 0), color = "blue", size = 1 ) +
  facet_wrap( ~cd_tool, nrow = 4, scales = 'free_y' ) +
  labs( x = 'sequencing depth', y = 'clone number error' ) +
  #ggtitle( 'Difference inferred number of clusters to truth' ) +
  theme_minimal()
ggsave( filename = 'plot/clust_num_depth.pdf', plot = p_clust_num_depth, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_num_depth.png', plot = p_clust_num_depth, device = 'png', width = 6, height = 6 )
p_clust_num_depth
```

```{r clust_num_cnv}
df_clust_cn2_seqz <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' )
p_clust_num_cnv <- df_clust_cn2_seqz %>%
  dplyr::filter( n_clust_inf <= 700 ) %>%
  ggplot( aes(x = cnv_burden, y = n_clust_inf - n_clust_true) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  scale_fill_gradient( low = 'white', high = 'red' ) +
  geom_hline(aes( yintercept = 0), color = "blue", size = .5 ) +
  geom_smooth( se = FALSE, color = 'green3', size = .5 ) +
  geom_point( size = .5 ) +
  facet_wrap( ~cd_tool, nrow = 4, scales = 'free_y' ) +
  labs( x = 'CNV burden', y = 'clone number error' ) +
  theme_minimal() +
  theme(legend.position = c(1,0),
        legend.justification = c(1, 0),
        legend.direction = 'horizontal')
p_clust_num_cnv <- shift_legend(p_clust_num_cnv)
ggsave( filename = 'plot/clust_num_cnv.pdf', plot = p_clust_num_cnv, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_num_cnv.png', plot = p_clust_num_cnv, device = 'png', width = 6, height = 6 )
p_clust_num_cnv
```

```{r clust_num_cnerr}
df_clust_cn2_seqz <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' )
p_clust_num_cnerr <- df_clust_cn2_seqz %>% 
  dplyr::filter( n_clust_inf <= 700 ) %>%
  ggplot( aes(x = log10(seqz_mse), y = n_clust_inf - n_clust_true) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  scale_fill_gradient( low = 'white', high = 'red' ) +
  geom_hline(aes( yintercept = 0), color = "blue", size = .5 ) +
  geom_smooth( se = FALSE, color = 'green3', size = .5 ) +
  geom_point( size = .1 ) +
  scale_x_continuous( breaks = seq(-6, 0, length.out = 5), 
                      labels = sprintf('%.2g', 10^(seq(log10(1e-6), log10(1), length.out = 5))) ) +
  #scale_x_continuous( trans = scales::pseudo_log_trans(base = 10), breaks = scales::trans_breaks('log10', function(x) 10^x) ) +
  facet_wrap( ~cd_tool, nrow = 4, scales = 'free_y' ) +
  labs( x = 'CN inference error', y = 'clone number error' ) +
  theme_minimal() +
  theme(legend.position = c(1,0),
        legend.justification = c(1, 0),
        legend.direction = 'horizontal')
p_clust_num_cnerr <- shift_legend(p_clust_num_cnerr)
ggsave( filename = 'plot/clust_num_cnerr.pdf', plot = p_clust_num_cnerr, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_num_cnerr.png', plot = p_clust_num_cnerr, device = 'png', width = 6, height = 6 )
p_clust_num_cnerr
```

#### Clustering metrics (ARI, V-measure)

Important clustering accuracy measures are the Adjusted Rand Index (ARI) and the V-measure, which is composed of homogeneity and completeness.

Let's calculate the correlation between clustering performance scores and their influencing variables.

```{r clust_cor}
df_clust_cn2_seqz <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F ) %>% 
  inner_join( df_rep, by = 'id_rep' )

df_clust_cor <- df_clust_cn2_seqz %>%
  rename( n_clone_inf = n_clust_inf, n_clone_true = n_clust_true ) %>% 
  group_by( cd_tool ) %>% 
  cor_test( 
    vars  = c('ARI', 'V_measure'), 
    vars2 = c('n_clone_true', 'n_samples', 'purity', 'n_snvs', 'depth', 'cnv_burden', 'seqz_mse') ) %>% 
  adjust_pvalue() %>% 
  add_significance(p.col = 'p.adj', cutpoints = psig_cut, symbols = psig_sym ) %>% 
  mutate( cor_sig = sprintf('%.2f (%s)', cor, p.adj.signif) ) %>% 
  pivot_wider( id_cols = c(cd_tool, var1), names_from = 'var2', values_from = c('cor', 'p.adj.signif') )
  #pivot_wider( id_cols = c(cd_tool, var1), names_from = 'var2', values_from = 'cor_sig' )
df_clust_cor %>% write_csv( 'df_clust_cor.csv' )
df_clust_cor
```

```{r, clust_metrics, warning=F}
# reorder callers by overall ARI score
df <- df_clust_cn2_seqz %>% mutate( lbl = fct_reorder(cd_tool, -ARI, .fun = median, na.rm = T) )
# perform Wilcoxon rank sum test for difference
pairs <- cbind(head(levels(df$lbl), -1), levels(df$lbl)[-1]) %>%
    t() %>% as_tibble() %>% as.list()
gwc_ari_wilcox <- df %>%
    wilcox_test( ., ARI ~ lbl, comparisons = pairs ) %>%
    adjust_pvalue( method = 'bonferroni' ) %>%
    add_significance( p.col = 'p.adj', output.col = 'sig_sym', cutpoints = psig_cut, symbols = psig_sym ) %>%
    add_xy_position( x = 'caller', step.increase = 0 ) %>%
    mutate( y.position = y.position + 0.05 )
gwc_v_wilcox <- df %>%
    wilcox_test( ., V_measure ~ lbl, comparisons = pairs ) %>%
    adjust_pvalue( method = 'bonferroni' ) %>%
    add_significance( p.col = 'p.adj', output.col = 'sig_sym', cutpoints = psig_cut, symbols = psig_sym ) %>%
    add_xy_position( x = 'caller', step.increase = 0 ) %>%
    mutate( y.position = y.position + 0.05 )
# gwc_comp_wilcox <- df %>%
#     wilcox_test( ., completeness ~ lbl, comparisons = pairs ) %>%
#     adjust_pvalue( method = 'bonferroni' ) %>%
#     add_significance( p.col = 'p.adj', output.col = 'sig_sym', cutpoints = psig_cut, symbols = psig_sym ) %>%
#     add_xy_position( x = 'caller', step.increase = 0 ) %>%
#     mutate( y.position = y.position + 0.05 )
# gwc_homog_wilcox <- df %>%
#     wilcox_test( ., homogeneity ~ lbl, comparisons = pairs ) %>%
#     adjust_pvalue( method = 'bonferroni' ) %>%
#     add_significance( p.col = 'p.adj', output.col = 'sig_sym', cutpoints = psig_cut, symbols = psig_sym ) %>%
#     add_xy_position( x = 'caller', step.increase = 0 ) %>%
#     mutate( y.position = y.position + 0.05 )


p_ari <- df %>% 
  dplyr::filter( n_clust_inf > 0 ) %>%
  pivot_longer( cols = ARI, names_to = 'metric' ) %>%
  mutate( metric = factor(metric, levels = c('ARI', 'V-measure', 'completeness', 'homogeneity'))) %>% 
  ggplot( aes(x = lbl, y = value) ) +
  geom_boxplot( aes(fill = metric) ) +
  scale_fill_manual( values = cbPalette[1], guide = FALSE) +
  stat_pvalue_manual( data = gwc_ari_wilcox, label = 'sig_sym', tip.length = .01, size = 4 ) +
  #facet_wrap( ~ metric, nrow = 1 ) +
  labs( x = '' ) + ggtitle( 'ARI' ) +
  theme_minimal() +
  theme( axis.text.x = element_text(angle = 45, hjust=1) )
p_vmeasure <- df %>% 
  dplyr::filter( n_clust_inf > 0 ) %>%
  pivot_longer( cols = V_measure, names_to = 'metric' ) %>%
  ggplot( aes(x = lbl, y = value) ) +
  geom_boxplot( aes(fill = metric ) ) +
  scale_fill_manual( values = cbPalette[2], guide = FALSE ) +
  stat_pvalue_manual( data = gwc_v_wilcox, label = 'sig_sym', tip.length = .01, size = 4 ) +
  #facet_wrap( ~ metric, nrow = 1 ) +
  labs( x = '' ) + ggtitle( 'V-measure' ) +
  theme_minimal() +
  theme( axis.text.x = element_text(angle = 45, hjust=1) )
# p_comp <- df %>% 
#   dplyr::filter( n_clust_inf > 0 ) %>%
#   pivot_longer( cols = completeness, names_to = 'metric' ) %>%
#   ggplot( aes(x = lbl, y = value) ) +
#   geom_boxplot() +
#   stat_pvalue_manual( data = gwc_comp_wilcox, label = 'sig_sym', tip.length = .01, size = 4 ) +
#   facet_wrap( ~ metric, nrow = 1 ) +
#   labs( x = '' ) + 
#   theme_minimal() +
#   theme( axis.text.x = element_text(angle = 45, hjust=1) )
# p_homog <- df %>% 
#   dplyr::filter( n_clust_inf > 0 ) %>%
#   pivot_longer( cols = homogeneity, names_to = 'metric' ) %>%
#   ggplot( aes(x = lbl, y = value) ) +
#   geom_boxplot() +
#   stat_pvalue_manual( data = gwc_homog_wilcox, label = 'sig_sym', tip.length = .01, size = 4 ) +
#   facet_wrap( ~ metric, nrow = 1 ) +
#   labs( x = '' ) + 
#   theme_minimal() +
#   theme( axis.text.x = element_text(angle = 45, hjust=1) )

p_comhom <- df %>% 
  dplyr::filter( n_clust_inf > 0 ) %>%
  pivot_longer( cols = c('completeness', 'homogeneity'), names_to = 'metric' ) %>%
  mutate( metric = factor(metric, levels = c('ARI', 'V-measure', 'completeness', 'homogeneity'))) %>% 
  ggplot( aes(x = lbl, y = value) ) +
  geom_boxplot( aes(fill = metric) ) +
  #scale_fill_manual( values = cbPalette[3:4] ) +
  scale_fill_manual( values = cbPalette, drop = FALSE,
                     name = 'metric',
                     breaks = c('ARI', 'V-measure', 'completeness', 'homogeneity')) +
  #facet_wrap( ~ metric, nrow = 1 ) +
  ggtitle( 'completeness / homogeneity' ) +
  labs( x = '' ) + 
  theme_minimal() +
  theme( axis.text.x = element_text(angle = 45, hjust=1) )


# p_clust_scores <- df %>% 
#   dplyr::filter( n_clust_inf > 0 ) %>%
#   pivot_longer( cols = c(ARI, V_measure, homogeneity, completeness), names_to = 'metric' ) %>%
#   ggplot( aes(x = lbl, y = value) ) +
#   geom_boxplot() +
#   stat_pvalue_manual( data = gwc_ari_wilcox, label = 'p.adj.signif', tip.length = .01, size = 2 ) +
#   #geom_violin() + geom_sina() +
#   facet_wrap( ~ metric, nrow = 1 ) +
#   labs( x = 'CD tool' ) + 
#   theme_minimal() +
#   theme( axis.text.x = element_text(angle = 45, hjust=1) )

# p_clust_scores <- ggarrange(
#     p_ari, p_vmeasure, p_comp, p_homog,
#     ncol = 2,
#     nrow = 2,
#     labels = "auto" , 
#     common.legend = TRUE, 
#     legend = "top",
#   )

p_clust_scores <- ggarrange(
    ggarrange(
      p_ari, p_vmeasure,
      ncol = 2,
      nrow = 1,
      labels = c('a', 'b')
    ),
    p_comhom,
    nrow = 2,
    labels = c('', 'c'), 
    common.legend = FALSE, 
    legend = 'bottom' )

ggsave( filename = 'plot/clust_metrics.pdf', plot = p_clust_scores, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_metrics.png', plot = p_clust_scores, device = 'png', width = 6, height = 6 )
p_clust_scores
```

#### Influence of true number of clones on clustering metrics

```{r, clust_metrics_nclones, warning=F}
# reorder callers by overall ARI score
df <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  mutate( lbl = fct_reorder(cd_tool, -ARI, .fun = median, na.rm = T) ) 

p_clust_scores_nclones <- df %>%
  dplyr::filter( n_clust_inf > 0 ) %>%
  pivot_longer( c('ARI', 'V_measure'), names_to = 'metric', values_to = 'value') %>%
  ggplot( aes(x = as.factor(n_clust_true), y = value, fill = metric) ) +
  geom_boxplot() +
  scale_fill_manual( values = cbPalette ) +
  facet_wrap( ~ lbl, nrow = 4 ) +
  labs( x = 'simulated number of clones', y = 'genotype accuracy' ) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust=1),
        legend.position = c(1,0),
        legend.justification = c(1, 0),
        legend.direction = 'horizontal')
p_clust_scores_nclones <- shift_legend(p_clust_scores_nclones)

ggsave( filename = 'plot/clust_metrics_nclones.pdf', plot = p_clust_scores_nclones, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_metrics_nclones.png', plot = p_clust_scores_nclones, device = 'png', width = 6, height = 6 )
p_clust_scores_nclones
```

#### Influence of number of samples on clustering metrics

```{r, clust_metrics_nsamples, warning=F}
# reorder callers by overall ARI score
df <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  mutate( lbl = fct_reorder(cd_tool, -ARI, .fun = median, na.rm = T) ) 

p_clust_scores_nsamples <- df %>%
  pivot_longer( c('ARI', 'V_measure'), names_to = 'metric', values_to = 'value') %>%
  ggplot( aes(x = as.factor(n_samples), y = value, fill = metric) ) +
  geom_boxplot() +
  scale_fill_manual( values = cbPalette ) +
  facet_wrap( ~ lbl, nrow = 4 ) +
  labs( x = 'number of samples', y = 'genotype accuracy' ) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust=1),
        legend.position = c(1,0),
        legend.justification = c(1, 0),
        legend.direction = 'horizontal')
p_clust_scores_nsamples <- shift_legend(p_clust_scores_nsamples)

ggsave( filename = 'plot/clust_metrics_nsamples.pdf', plot = p_clust_scores_nsamples, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_metrics_nsamples.png', plot = p_clust_scores_nsamples, device = 'png', width = 6, height = 6 )
p_clust_scores_nsamples
```

```{r clust_metrics_purity}
# reorder callers by overall ARI score
df <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  mutate( lbl = fct_reorder(cd_tool, -ARI, .fun = median, na.rm = T) ) 

p_clust_scores_purity <- df %>%
  pivot_longer( c('ARI', 'V_measure'), names_to = 'metric', values_to = 'value') %>%
  ggplot( aes(x = purity, y = value) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  scale_fill_gradient( low = 'white', high = 'red', limits = c(0, 10) ) +
  geom_point( size = .1 ) +
  geom_smooth( method = 'loess', se = FALSE, color = 'green3', size = .5 ) +
  facet_nested_wrap( ~ lbl + metric, nrow = 4 ) +
  labs( x = 'tumor purity', y = 'genotype accuracy' ) +
  #ggtitle( 'Difference inferred number of clusters to truth' ) + 
  theme_minimal() +
  theme(legend.position = c(1,0),
        legend.justification = c(1, 0),
        legend.direction = 'horizontal')
p_clust_scores_purity <- shift_legend(p_clust_scores_purity)
ggsave( filename = 'plot/clust_metrics_purity.pdf', plot = p_clust_scores_purity, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_metrics_purity.png', plot = p_clust_scores_purity, device = 'png', width = 6, height = 6 )
p_clust_scores_purity
```

```{r clust_metrics_nsnvs}
# reorder callers by overall ARI score
df <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  mutate( lbl = fct_reorder(cd_tool, -ARI, .fun = median, na.rm = T) ) 

p_clust_scores_nsnvs <- df %>%
  pivot_longer( c('ARI', 'V_measure'), names_to = 'metric', values_to = 'value') %>%
  ggplot( aes(x = n_snvs, y = value) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  scale_fill_gradient( low = 'white', high = 'red', limits = c(0, 1e-3) ) +
  geom_point( size = .1 ) +
  geom_smooth( method = 'loess', se = FALSE, color = 'green3', size = .5 ) +
  scale_x_continuous( labels = scientific, breaks = pretty_breaks(n = 3) ) +
  facet_nested_wrap( ~ lbl + metric, nrow = 4 ) +
  labs( x = 'number of SNVs', y = 'genotype accuracy' ) +
  theme_minimal() +
  theme( 
    axis.text = element_text(size = 6),
    legend.position = c(1,0),
        legend.justification = c(1, 0))
p_clust_scores_nsnvs <- shift_legend(p_clust_scores_nsnvs)
ggsave( filename = 'plot/clust_metrics_nsnvs.pdf', plot = p_clust_scores_nsnvs, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_metrics_nsnvs.png', plot = p_clust_scores_nsnvs, device = 'png', width = 6, height = 6 )
p_clust_scores_nsnvs
```

```{r, clust_metrics_depth, warning=F}
# reorder callers by overall ARI score
df <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  mutate( lbl = fct_reorder(cd_tool, -ARI, .fun = median, na.rm = T) ) 

p_clust_scores_depth <- df %>%
  pivot_longer( c('ARI', 'V_measure'), names_to = 'metric', values_to = 'value') %>%
  ggplot( aes(x = as.factor(depth), y = value, fill = metric) ) +
  geom_boxplot() +
  scale_fill_manual( values = cbPalette ) +
  facet_wrap( ~ lbl, nrow = 2 ) +
  labs( x = 'sequencing depth', y = 'genotype accuracy' ) + 
  theme_minimal() +
  theme( legend.position = c(1,0),
         legend.justification = c(1, 0))
p_clust_scores_depth <- shift_legend(p_clust_scores_depth)
ggsave( filename = 'plot/clust_metrics_depth.pdf', plot = p_clust_scores_depth, device = 'pdf', width = 8, height = 6 )
ggsave( filename = 'plot/clust_metrics_depth.png', plot = p_clust_scores_depth, device = 'png', width = 8, height = 6 )
p_clust_scores_depth
```

```{r clust_metrics_cnv}
df <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  mutate( lbl = fct_reorder(cd_tool, -ARI, .fun = median, na.rm = T) )

p_clust_scores_cnv <- df %>%
  pivot_longer( c('ARI', 'V_measure'), names_to = 'metric', values_to = 'value') %>%
  ggplot( aes(x = cnv_burden, y = value) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  scale_fill_gradient( low = 'white', high = 'red', limits = c(0, 10) ) +
  geom_point( size = .1 ) +
  geom_smooth( se = FALSE, color = 'green3', size = .5 ) +
  facet_nested_wrap( ~ lbl + metric, nrow = 4 ) +
  labs( x = 'CNV burden', y = 'genotype accuracy' ) +
  theme_minimal() +
  theme( legend.position = c(1,0),
         legend.justification = c(1, 0),
        legend.direction = 'horizontal')
p_clust_scores_cnv <- shift_legend(p_clust_scores_cnv)
ggsave( filename = 'plot/clust_metrics_cnv.pdf', plot = p_clust_scores_cnv, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_metrics_cnv.png', plot = p_clust_scores_cnv, device = 'png', width = 6, height = 6 )
p_clust_scores_cnv
```

```{r clust_metrics_cnerr}
df <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  mutate( lbl = fct_reorder(cd_tool, -ARI, .fun = median, na.rm = T) )

p_clust_scores_cnerr <- df %>%
  pivot_longer( c('ARI', 'V_measure'), names_to = 'metric', values_to = 'value') %>%
  ggplot( aes(x = log10(seqz_mse), y = value) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  scale_fill_gradient( low = 'white', high = 'red', limits = c(0, 1.5) ) +
  geom_smooth( se = FALSE, color = 'green3', size = .5 ) +
  geom_point( size = .1 ) +
  scale_x_continuous( breaks = seq(-6, 0, length.out = 4), 
                      labels = sprintf('%.2g', 10^(seq(log10(1e-6), log10(1), length.out = 4))) ) +
  facet_nested_wrap( ~ lbl + metric, nrow = 4 ) +
  labs( x = 'CN inference error', y = 'genotype accuracy' ) +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 6),
        legend.position = c(1,0),
        legend.justification = c(1, 0),
        legend.direction = 'horizontal')
p_clust_scores_cnerr <- shift_legend(p_clust_scores_cnerr)
ggsave( filename = 'plot/clust_metrics_cnerr.pdf', plot = p_clust_scores_cnerr, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/clust_metrics_cnerr.png', plot = p_clust_scores_cnerr, device = 'png', width = 6, height = 6 )
p_clust_num_cnerr
```

### Cellular prevalence accuracy

Clonal deconvolution tools typically output the cellular prevalence, or cancer cell fraction (CCF), of each inferred clone. To gauge how similar these inferred prevalences are to the simulated ones, we calculate the mean squared error between both values for all mutations. For this, I assigned each mutation the prevalence of the inferred cluster it was assigned to.

```{r, prev_metrics, message=F}
# fn_metr_prev <- file.path( data_dir, 'metrics_prevalence.csv' )
# df_metr_prev <- read_csv( fn_metr_prev ) %>% 
#   separate( tool, c('cd_tool', 'cn_filter', 'cn_tool'), sep = '_', remove = FALSE, fill = 'right' ) %>% 
#   replace_na( list(cn_tool = 'seqz') )

df_prev_cn2_seqz <- df_metr_prev %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F )

# reorder callers by median MSE
df <- df_prev_cn2_seqz %>% 
  mutate( cd_tool = fct_reorder(cd_tool, prev_msq, .fun = median, na.rm = T) )

# perform Wilcoxon rank sum test for difference
pairs <- cbind(head(levels(df$cd_tool), -1), levels(df$cd_tool)[-1]) %>%
    t() %>% as_tibble() %>% as.list()
gwc_msq_wilcox <- df %>%
    wilcox_test( ., prev_msq ~ cd_tool, comparisons = pairs ) %>%
    adjust_pvalue( method = 'bonferroni' ) %>%
    add_significance( p.col = 'p.adj', output.col = 'sig_sym', cutpoints = psig_cut, symbols = psig_sym ) %>%
    add_xy_position( x = 'cd_tool', step.increase = 0 ) %>%
    mutate( y.position = y.position + 0.05 )

p_prev_msq <- df %>%
  ggplot( aes(x = cd_tool, y = prev_msq) ) +
  geom_boxplot() +
  stat_pvalue_manual( data = gwc_msq_wilcox, label = 'sig_sym', tip.length = .01, size = 4 ) +
  #geom_violin() + geom_sina() +
  labs( x = '', y = 'Prevalence error') +
  theme_minimal()
  #theme( axis.text.x = element_text(angle = 45, hjust=1) )
ggsave( filename = 'plot/prev_mse.pdf', plot = p_prev_msq, device = 'pdf', width = 8, height = 3 )
ggsave( filename = 'plot/prev_mse.png', plot = p_prev_msq, device = 'png', width = 8, height = 3 )
p_prev_msq
```

SciClone does not output a prevalence estimate per cluster, but probabilistic cluster assignment for each variant. We could use the read counts to for each sample and use that as "inferred prevalence" but might be giving SciClone a preferential treatment.

Do influence factors correlate with prevalence inference error?

```{r prev_corr}
df_prev_cn2_seqz <- df_metr_prev %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F ) %>% 
  inner_join( df_rep, by = 'id_rep' )

df_prev_cor <- df_prev_cn2_seqz %>%
  rename( prev_mse = prev_msq ) %>% 
  group_by( cd_tool ) %>% 
  cor_test( 
    vars  = c('prev_mse'), 
    vars2 = c('n_clust_true', 'n_samples', 'purity', 'n_snvs', 'depth', 'cnv_burden', 'seqz_mse') ) %>% 
  adjust_pvalue() %>% 
  add_significance(p.col = 'p.adj', cutpoints = psig_cut, symbols = psig_sym ) %>% 
  #mutate( cor_sig = sprintf('%.2f (%s)', cor, p.adj.signif) ) %>% 
  pivot_wider( id_cols = c(cd_tool, var1), names_from = 'var2', values_from = c('cor', 'p.adj.signif') )
  #pivot_wider( id_cols = c(cd_tool, var1), names_from = 'var2', values_from = 'cor_sig' )
df_prev_cor %>% write_csv( 'df_prev_cor.csv' )
df_prev_cor
```

```{r prev_nclones}
p_prev_nclones <- df_prev_cn2_seqz %>% 
  ggplot( aes(x = as.factor(n_clust_true), y = prev_msq) ) +
  geom_violin() + geom_boxplot( width = .2 ) +
  facet_wrap( ~cd_tool, nrow = 4, scales = 'free_y' ) +
  labs( x = 'simulated no. clones', y = 'prevalence error' ) +
  theme_minimal()
ggsave( filename = 'plot/prev_nclones.pdf', plot = p_prev_nclones, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/prev_nclones.png', plot = p_prev_nclones, device = 'png', width = 6, height = 6 )
p_prev_nclones
```

```{r prev_nsamples}
p_prev_nsamples <- df_prev_cn2_seqz %>% 
  inner_join( df_rep, by = 'id_rep' ) %>% 
  ggplot( aes(x = as.factor(n_samples), y = prev_msq) ) +
  geom_violin() + geom_boxplot( width = .2 ) +
  facet_wrap( ~cd_tool, nrow = 4, scales = 'free_y' ) +
  labs( x = 'number of samples', y = 'prevalence error' ) +
  theme_minimal()
ggsave( filename = 'plot/prev_nsamples.pdf', plot = p_prev_nsamples, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/prev_nsamples.png', plot = p_prev_nsamples, device = 'png', width = 6, height = 6 )
p_prev_nsamples
```

```{r prev_purity}
p_prev_purity <- df_prev_cn2_seqz %>%
  ggplot( aes(x = purity, y = prev_msq) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  #scale_fill_distiller(palette= "Spectral", direction=1) +
  scale_fill_gradient( low = 'white', high = 'red' ) +
  geom_smooth( se = FALSE, color = 'green3', size = .5 ) +
  geom_point( size = .5 ) +
  facet_wrap( ~cd_tool, nrow = 4, scales = 'free_y' ) +
  labs( x = 'tumor purity', y = 'prevalence error' ) +
  theme_minimal() +
  theme( axis.text = element_text(size = 8) ) +
  theme(legend.position = c(1,0),
        legend.justification = c(1, 0),
        legend.direction = 'horizontal')
p_prev_purity <- shift_legend(p_prev_purity)
ggsave( filename = 'plot/prev_purity.pdf', plot = p_prev_purity, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/prev_purity.png', plot = p_prev_purity, device = 'png', width = 6, height = 6 )
p_prev_purity
```

```{r prev_nsnvs}
p_prev_nsnvs <- df_prev_cn2_seqz %>%
  ggplot( aes(x = n_snvs, y = prev_msq) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  #scale_fill_distiller(palette= "Spectral", direction=1) +
  scale_fill_gradient( low = 'white', high = 'red' ) +
  geom_smooth( se = FALSE, color = 'green3', size = .5 ) +
  geom_point( size = .5 ) +
  facet_wrap( ~cd_tool, nrow = 4, scales = 'free_y' ) +
  labs( x = 'number of SNVs', y = 'prevalence error' ) +
  theme_minimal() +
  theme( axis.text = element_text(size = 8) ) +
  theme(legend.position = c(1,0),
        legend.justification = c(1, 0))
p_prev_nsnvs <- shift_legend(p_prev_nsnvs)
ggsave( filename = 'plot/prev_nsnvs.pdf', plot = p_prev_nsnvs, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/prev_nsnvs.png', plot = p_prev_nsnvs, device = 'png', width = 6, height = 6 )
p_prev_nsnvs
```

```{r prev_depth}
p_prev_depth <- df_prev_cn2_seqz %>%
  ggplot( aes(x = as.factor(depth), y = prev_msq) ) +
  geom_violin() + geom_boxplot( width = .2 ) +
  facet_wrap( ~ cd_tool, nrow = 4 ) +
  labs( x = 'sequencing depth', y = 'prevalence error' ) + 
  theme_minimal() +
  theme( legend.position = c(1,0),
         legend.justification = c(1, 0))
ggsave( filename = 'plot/prev_depth.pdf', plot = p_prev_depth, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/prev_depth.png', plot = p_prev_depth, device = 'png', width = 6, height = 6 )
p_prev_depth
```

```{r prev_cnv}
p_prev_cnv <- df_prev_cn2_seqz %>%
  ggplot( aes(x = cnv_burden, y = prev_msq) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  scale_fill_gradient( low = 'white', high = 'red' ) +
  geom_point( size = .1 ) +
  geom_smooth( se = FALSE, color = 'green3', size = .5 ) +
  facet_wrap( ~ cd_tool, nrow = 4 ) +
  labs( x = 'CNV burden', y = 'prevalence error' ) +
  theme_minimal() +
  theme( legend.position = c(1,0),
         legend.justification = c(1, 0),
         legend.direction = 'horizontal')
p_prev_cnv <- shift_legend(p_prev_cnv)
ggsave( filename = 'plot/prev_cnv.pdf', plot = p_prev_cnv, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/prev_cnv.png', plot = p_prev_cnv, device = 'png', width = 6, height = 6 )
p_clust_scores_cnv
```

```{r prev_cnerr}
df <- df_clust %>% 
  dplyr::filter( n_clust_inf > 0, cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  mutate( lbl = fct_reorder(cd_tool, -ARI, .fun = median, na.rm = T) )

p_prev_cnerr <- df_prev_cn2_seqz %>%
  ggplot( aes(x = log10(seqz_mse), y = prev_msq) ) +
  stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
  scale_fill_gradient( low = 'white', high = 'red', limits = c(0, 5) ) +
  geom_smooth( se = FALSE, color = 'green3', size = .5 ) +
  geom_point( size = .1 ) +
  scale_x_continuous( breaks = seq(-6, 0, length.out = 4), 
                      labels = sprintf('%.2g', 10^(seq(log10(1e-6), log10(1), length.out = 4))) ) +
  facet_wrap( ~ cd_tool, nrow = 4 ) +
  labs( x = 'CN inference error', y = 'prevalence error' ) +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 6),
        legend.position = c(1,0),
        legend.justification = c(1, 0),
        legend.direction = 'horizontal')
p_prev_cnerr <- shift_legend(p_prev_cnerr)
ggsave( filename = 'plot/prev_cnerr.pdf', plot = p_prev_cnerr, device = 'pdf', width = 6, height = 6 )
ggsave( filename = 'plot/prev_cnerr.png', plot = p_prev_cnerr, device = 'png', width = 6, height = 6 )
p_clust_num_cnerr
```

### Phylogenetic accuracy

For clonal deconvolution tools that output a clone phylogeny, the tree distance metrics CASet and DISC are reported.

```{r, phylo_load_data, message=F}
fn_phylo <- file.path( data_dir, 'metrics_phylogeny.csv' )
df_phylo <- read_csv( fn_phylo ) %>% 
  separate( tool, c('cd_tool', 'cn_filter', 'cn_tool'), sep = '_', remove = FALSE, fill = 'right' ) %>% 
  replace_na( list(cn_tool = 'seqz') )

df_phylo_cn2_seqz <- df_phylo %>% 
  dplyr::filter( cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F )

# reorder callers by median CASet_isect
df <- df_phylo_cn2_seqz %>% mutate( cd_tool = fct_reorder(cd_tool, CASet_isect, .fun = median, na.rm = T) )

# # perform Wilcoxon rank sum test for difference
# pairs <- cbind(head(levels(df$cd_tool), -1), levels(df$cd_tool)[-1]) %>%
#     t() %>% as_tibble() %>% as.list()
# gwc_msq_wilcox <- df %>%
#     wilcox_test( ., prev_msq ~ cd_tool, comparisons = pairs ) %>%
#     adjust_pvalue( method = 'bonferroni' ) %>%
#     add_significance( p.col = 'p.adj', output.col = 'sig_sym' ) %>%
#     add_xy_position( x = 'cd_tool', step.increase = 0 ) %>%
#     mutate( y.position = y.position + 0.05 )

p_phylo <- df %>%
  pivot_longer( cols = c(CASet_isect, CASet_union, DISC_isect, DISC_union), names_to = 'metric' ) %>%
  ggplot( aes(x = cd_tool, y = value) ) +
  geom_boxplot() +
  #geom_violin() + geom_sina() +
  facet_wrap( ~ metric ) +
  labs( x = '' ) +
  theme_minimal() #+
  #theme( axis.text.x = element_text(angle = 45, hjust=1) )
ggsave( filename = 'plot/phylo.pdf', plot = p_phylo, device = 'pdf', width = 8, height = 3 )
ggsave( filename = 'plot/phylo.png', plot = p_phylo, device = 'png', width = 8, height = 3 )
p_phylo
```

Notes / Observations:

* Cloe and CloneFinder produced trees including homoplasies, which do not have a defined CASet or DISC distance

```{r clust_cor}
df_phylo_cn2_seqz <- df_phylo %>% 
  dplyr::filter( cn_tool == 'seqz', cn_filter == 'cn2' ) %>%
  unite( 'lbl', cn_filter, cn_tool, sep = '\n', remove = F )

df_phylo_cor <- df_phylo_cn2_seqz %>%
  inner_join( df_rep, by = 'id_rep' ) %>%
  group_by( cd_tool ) %>% 
  cor_test( 
    vars  = c('CASet_isect', 'CASet_union', 'DISC_isect', 'DISC_union'), 
    vars2 = c('n_clones', 'n_samples', 'purity', 'n_snvs', 'depth') ) %>% 
  adjust_pvalue() %>% 
  add_significance(p.col = 'p.adj' ) %>% 
  mutate( cor_sig = sprintf('%.2f (%s)', cor, p.adj.signif) ) %>% 
  pivot_wider( id_cols = c(cd_tool, var1), names_from = 'var2', values_from = c('cor', 'p.adj.signif') )
  #pivot_wider( id_cols = c(cd_tool, var1), names_from = 'var2', values_from = 'cor_sig' )
df_phylo_cor %>% write_csv( 'df_phylo_cor.csv' )
df_phylo_cor
```

```{r, phylo_nclones, warning=F}
# reorder callers by overall ARI score
df <- df_phylo_cn2_seqz %>% mutate( lbl = fct_reorder(cd_tool, -ARI, .fun = median, na.rm = T) ) 

p_phlyo_nclones <- df_phylo_cn2_seqz %>%
  #dplyr::filter( n_clust_inf > 0 ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  pivot_longer( c('CASet_isect', 'CASet_union', 'DISC_isect', 'DISC_union'), names_to = 'metric', values_to = 'value') %>%
  ggplot( aes(x = as.factor(n_clones), y = value, fill = metric) ) +
  geom_boxplot() +
  scale_fill_brewer( palette = 'Set1' ) +
  facet_wrap( ~ cd_tool, nrow = 2 ) +
  labs( x = 'true number of clones', y = '' ) + 
  theme_minimal() +
  theme( axis.text.x = element_text(angle = 45, hjust=1),
         legend.position = 'top' )

ggsave( filename = 'plot/phylo_nclones.pdf', plot = p_phlyo_nclones, device = 'pdf', width = 8, height = 6 )
ggsave( filename = 'plot/phylo_nclones.png', plot = p_phlyo_nclones, device = 'png', width = 8, height = 6 )
p_phlyo_nclones
```

```{r, phylo_nsamples, warning=F}
p_phlyo_nsamples <- df_phylo_cn2_seqz %>%
  #dplyr::filter( n_clust_inf > 0 ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  pivot_longer( c('CASet_isect', 'CASet_union', 'DISC_isect', 'DISC_union'), names_to = 'metric', values_to = 'value') %>%
  ggplot( aes(x = as.factor(n_samples), y = value, fill = metric) ) +
  geom_boxplot() +
  scale_fill_brewer( palette = 'Set1' ) +
  facet_wrap( ~ cd_tool, nrow = 2 ) +
  labs( x = 'number of samples', y = '' ) + 
  theme_minimal() +
  theme( axis.text.x = element_text(angle = 45, hjust=1),
         legend.position = 'top' )

ggsave( filename = 'plot/phylo_nsamples.pdf', plot = p_phlyo_nsamples, device = 'pdf', width = 8, height = 6 )
ggsave( filename = 'plot/phylo_nsamples.png', plot = p_phlyo_nsamples, device = 'png', width = 8, height = 6 )
p_phlyo_nsamples
```

```{r phylo_purity}
p_phylo_purity <- df_phylo_cn2_seqz %>%
  #dplyr::filter( n_clust_inf > 0 ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  pivot_longer( c('CASet_isect', 'CASet_union', 'DISC_isect', 'DISC_union'), names_to = 'metric', values_to = 'value') %>%
  ggplot( aes(x = purity, y = value) ) +
  geom_smooth( method = 'loess' ) +
  geom_point( size = .1 ) +
  facet_grid( metric~cd_tool ) +
  labs( x = 'tumor purity', y = '' ) +
  theme_minimal() +
  theme( axis.text = element_text(size = 6) )
ggsave( filename = 'plot/phylo_purity.pdf', plot = p_phylo_purity, device = 'pdf', width = 8, height = 6 )
ggsave( filename = 'plot/phylo_purity.png', plot = p_phylo_purity, device = 'png', width = 8, height = 6 )
p_phylo_purity
```

```{r phylo_nsnvs}
p_phylo_nsnvs <- df_phylo_cn2_seqz %>%
  #dplyr::filter( n_clust_inf > 0 ) %>%
  inner_join( df_rep, by = 'id_rep' ) %>% 
  pivot_longer( c('CASet_isect', 'CASet_union', 'DISC_isect', 'DISC_union'), names_to = 'metric', values_to = 'value') %>%
  ggplot( aes(x = n_snvs, y = value) ) +
  geom_smooth( method = 'loess' ) +
  geom_point( size = .1 ) +
  facet_grid( metric~cd_tool ) +
  labs( x = 'number of SNVs', y = '' ) +
  theme_minimal() +
  theme( axis.text = element_text(size = 6) )
ggsave( filename = 'plot/phylo_nsnvs.pdf', plot = p_phylo_nsnvs, device = 'pdf', width = 8, height = 6 )
ggsave( filename = 'plot/phylo_nsnvs.png', plot = p_phylo_nsnvs, device = 'png', width = 8, height = 6 )
p_phylo_nsnvs
```

### Runtime resources

Clonal deconvolution tools exhibit vastly different resource use profiles.

```{r resources_load_data}
# load information about executed jobs
df_slurm_log <- read_csv( file.path(data_dir, 'slurm_logs.csv'),
                          col_names = c('id_job', 'job_name', 'cohort', 'id_rep'),
                          col_types = 'iccc' ) %>% 
  dplyr::filter( !grepl('strict$', job_name) ) %>% 
  dplyr::filter( !job_name %in% c('canopy', 'sequenza', 'spruce', 'tgs') ) %>% 
  extract( job_name, 'cd_tool', '^([^_]+)', remove = F ) %>% 
  mutate( cd_tool = gsub('pyclone-vi', 'pyclonevi', cd_tool) )
df_job_info <- read_csv( file.path(data_dir, 'slurm_jobs.fix.csv'),
                         col_names = c('id_job', 'job_name', 'ncores', 'rep_path'),
                         col_types = 'icic' ) %>% 
  dplyr::filter( !grepl('strict$', job_name) )
df_job_res <- read_csv( file.path(data_dir, 'slurm_perf.csv'),
                        col_names = c('id_job', 'batch', 'start_str', 'end_str', 'duration_str', 'mem_max_str', 'node'),
                        col_types = 'icccccc') %>% 
  mutate( 
    mem_max = as.numeric(gsub('.$', '', mem_max_str)),
    date_start = parse_datetime(start_str),
    date_end   = parse_datetime(end_str),
    duration_s = date_end - date_start)
# join info
df_jobs <- df_slurm_log %>% 
  inner_join( df_job_info, by = 'id_job' ) %>% 
  inner_join( df_job_res, by = 'id_job' )
# aggregate resources by replicate
df_jobs_agg <- df_jobs %>% 
  group_by( cd_tool, cohort, id_rep ) %>% 
  summarise( duration_sec = ncores * as.numeric(sum(duration_s)), mem_max = max(mem_max) ) %>% 
  mutate(
    duration_cpu_hours = duration_sec / 3600,
    mem_max_gb = mem_max / 1024 / 1024)
```
```{r resources}
# reorder callers by median MSE
df <- df_jobs_agg %>% ungroup() %>% mutate( cd_tool = fct_reorder(cd_tool, duration_cpu_hours, .fun = median, na.rm = T) )

p_compres <- df %>% pivot_longer( cols = c('duration_cpu_hours', 'mem_max_gb'), names_to = 'metric', values_to = 'value' ) %>% 
  ggplot( aes(x = cd_tool, y = value) ) +
  geom_boxplot() +
  facet_wrap( ~ metric, scales = 'free' ) +
  labs( x = '', y = '' ) +
  coord_flip() +
  theme_minimal()
ggsave( filename = 'plot/compres.pdf', plot = p_compres, device = 'pdf', width = 8, height = 3 )
ggsave( filename = 'plot/compres.png', plot = p_compres, device = 'png', width = 8, height = 3 )
p_compres
```

## Failure conditions

```{r fail_clonefinder}
df_fail_clofi <- read_csv(file.path(data_dir, 'clonefinder.msg.csv'),
                          col_names = c('id_rep', 'job_name', 'msg')) %>% 
  mutate( reason = ifelse(grepl('taxa', msg), '<4 taxa', ifelse(grepl('parsimony', msg), 'inf sites', 'unknown')) ) %>% 
  inner_join( df_rep, by = 'id_rep' )

df_fail_clofi %>% group_by( reason ) %>% tally()

p_fail_clofi <- df_fail_clofi %>% pivot_longer( cols = c('n_clones', 'n_samples', 'purity', 'n_snvs', 'depth')) %>% 
  ggplot( aes(x = reason, y = value, fill = reason) ) + geom_violin( ) + geom_sina(alpha=.4) + 
  facet_wrap( ~name, nrow = 1, scales = 'free_y' ) +
  theme_minimal() +
  theme( axis.text.x = element_text(angle = 45, hjust = 1))
ggsave( filename = 'plot/fail_clonefinder.pdf', plot = p_fail_clofi, device = 'pdf', width = 8, height = 3 )
ggsave( filename = 'plot/fail_clonefinder.png', plot = p_fail_clofi, device = 'png', width = 8, height = 3 )
p_fail_clofi
```

